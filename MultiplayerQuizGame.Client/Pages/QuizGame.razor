@using System.Timers
@using System.Security.Claims
@inject IQuizService QuizService
@inject IUserRepository UserRepository
@inject IQuizRepository QuizRepository

@page "/quiz/{Id}"
@rendermode InteractiveWebAssembly



<h3>Quiz @Id</h3>
<HeadContent>
    <link rel="stylesheet" href="app_client.css" />
</HeadContent>
@if (!isLoaded)
{
    <span>Loading...</span>
}
else
{
    <div class="w-full p-8 bg-white rounded-lg shadow-lg">
    @if(isQuestionFinished)
    {
            <span class="bg-green-700 text-green-100 text-sm font-bold me-2 px-2.5 py-0.5 rounded dark:bg-green-900 dark:text-green-300">Time: @ResultCountdownText</span>
            <h2 class="mb-4 text-center text-4xl font-extrabold leading-none tracking-tight text-gray-900 md:text-5xl lg:text-6xl dark:text-white">You have:@points points 🔥</h2>

    }
    @if (_chosenQuiz != null && !isQuizFinished && !isQuestionFinished)
    {
        <span class="bg-green-700 text-green-100 text-sm font-bold me-2 px-2.5 py-0.5 rounded dark:bg-green-900 dark:text-green-300">Time: @CountdownText</span>
        <span>Score: @score/@_chosenQuiz.QuestionCount</span>
        <span>Points: @points</span>
            <CurrentQuestion Question="_currentQuestion" OnAnswerCheck="CheckAnswer" />
       
    }
    else if (isQuizFinished)
    {
        <h2 class="mb-4 text-center text-4xl font-extrabold leading-none tracking-tight text-gray-900 md:text-5xl lg:text-6xl dark:text-white">Quiz finished</h2>
        <h5 class="mb-4 text-center text-4xl font-extrabold leading-none tracking-tight text-gray-400 md:text-5xl lg:text-6xl dark:text-white">Score: @score/@_chosenQuiz.QuestionCount</h5>

    }
    </div>



}
@code {
    const int MAX_QUESTION_SCORE = 100;
    const int MAX_QUESTION_SECONDS = 15;
    const int MAX_RESULT_SECONDS = 5;
    const int ONE_SECOND = 1000;

    bool isQuestionFinished = false;
    bool isLoaded = false;
    bool isQuizFinished = false;


    int countdownSeconds = MAX_QUESTION_SECONDS;
    int resultSeconds = MAX_RESULT_SECONDS;
    string CountdownText => $"{countdownSeconds/60:00}:{countdownSeconds}";
    string ResultCountdownText => $"{resultSeconds / 60:00}:{resultSeconds}";


    int score = 0;
    float points = 0;
    int questionNr = 0;


    private Timer _questionTimer = null!;
    private Timer _resultTimer = null;

    private QuizDto? _chosenQuiz;
    private QuestionDto? _currentQuestion;
    private UserQuizStampDto? _stampDto;
    private string? _userId;
    private IEnumerable<Claim> _claims = Enumerable.Empty<Claim>();
    [CascadingParameter]
    private Task<AuthenticationState>? _authenticationState { get; set; }
    [Parameter]
    public string Id { get; set; }
    protected override async Task OnInitializedAsync()
    {
        _chosenQuiz = await QuizRepository.GetQuizDto(Int32.Parse(Id));
        _currentQuestion = await QuizRepository.GetQuestionDto(_chosenQuiz.Id, questionNr++);

        var authState = await _authenticationState;
        var user = authState.User;

        if (user.Identity is not null && user.Identity.IsAuthenticated)
        {
            _claims = user.Claims;
            _userId = user.FindFirst(c => c.Type is "id")?.Value;

            _stampDto = await UserRepository.SaveQuizStamp(new UserQuizStampDto
                {
                    UserId = int.Parse(_userId),
                    QuizId = _chosenQuiz.Id,

                });
        }
        InitTimer(ref _questionTimer, OnQuestionTimedEvent);
    }
    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            isLoaded = true;
        }

    }

    public async void ChangeQuestion()
    {
        if (questionNr < _chosenQuiz.QuestionCount)
        {
            _currentQuestion = await QuizRepository.GetQuestionDto(_chosenQuiz.Id, questionNr++);
            countdownSeconds = MAX_QUESTION_SECONDS;
        }
        else
        {
            isQuizFinished = true;
            await UpdateStampPoints();
            Dispose(_questionTimer);
            Dispose(_resultTimer);
        }

    }
    public void IncrementScore()
    {
        Console.WriteLine(MAX_QUESTION_SCORE * (countdownSeconds / MAX_QUESTION_SECONDS));
        points += (MAX_QUESTION_SCORE * (float)((float)countdownSeconds / (float)MAX_QUESTION_SECONDS));
        score++;
        StateHasChanged();
    }
    public async void ShowQuestionResult()
    {

        if (_resultTimer is null)
        {
            InitTimer(ref _resultTimer, OnResultTimedEvent);
        }
        else
        {
            _resultTimer.Start();
        }
        isQuestionFinished = true;

    }

    public async void CheckAnswer(QuestionChoiceDto answer)
    {
        if (await QuizService.CheckAnswer(_currentQuestion.Id, answer) == true)
        {
            IncrementScore();
        }
        ShowQuestionResult();
    }

    public async Task UpdateStampPoints()
    {
        var authState = await _authenticationState;
        var user = authState.User;
        if (user.Identity is not null && user.Identity.IsAuthenticated)
        {
            _stampDto.Points = (int)points;
            await UserRepository.SaveQuizStamp(_stampDto);
        }

    }
    //TIMER METHODS
    void InitTimer(ref Timer timer, ElapsedEventHandler elapsedEvent)
    {
        timer = new Timer(ONE_SECOND);
        timer.Elapsed += elapsedEvent;
        timer.AutoReset = true;
        timer.Enabled = true;
    }
    private async void OnResultTimedEvent(object? sender, ElapsedEventArgs e)
    {
        resultSeconds--;
        if (resultSeconds == 0)
        {
            _resultTimer.Stop();
            isQuestionFinished = false;
            resultSeconds = MAX_RESULT_SECONDS;
            _questionTimer.Start();
            
        }
        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }
    private void OnQuestionTimedEvent(object? sender, ElapsedEventArgs e)
    {
        countdownSeconds--;

        if (countdownSeconds == 0)
        {
            _questionTimer.Stop();
            countdownSeconds = MAX_QUESTION_SECONDS;
            ShowQuestionResult();
        }
        InvokeAsync(() =>
        {
            StateHasChanged();
        });
       
    }
    void Dispose(Timer timer)
    {
        timer?.Dispose();
    }



    
}
